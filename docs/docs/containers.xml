<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="stylesheet.xsl"?>

<doc>
   <title>Containers</title>

   <!-- ************************************************************************* -->

   <body>
         <p>
         Many of these containers were inspired by the work of the <a
           href="http://www.cse.ohio-state.edu/~weide/rsrg/index.html">Reusable
           Software Research Group</a> at Ohio State.  As such, many of the objects do not support
         copying in any form, only swapping is allowed. That is, when objects
         are added or removed from most of these containers they are swapped in
         and out, not copied. 
         </p>

         <p>
         This allows you to do things like have containers of containers of
         containers without encountering the overhead of the massive copying
         that would likely result if you did the same thing with the STL.  It
         also means you can store objects that are not copyable inside these
         containers, which is not something you can do with the STL prior to C++11.  
         </p>

         <p>
         Note that it is assumed by these containers that swap() and
         operator&lt; do not throw.  They may not function correctly if this
         assumption is broken.  Also note that the built in types (int, long,
         char, etc.) and std::string will not cause operator&lt; or swap() to
         throw.
         </p>

         <p>
            Note also that most of the containers inherit from the 
            <a href="#enumerable">enumerable</a> interface.  Thus, all the
            member functions inherited from enumerable are defined in the
            enumerable class and their documentation is not repeated in each
            container's documentation.  This includes the size() member
            function in each container.
         </p>

   
   </body>

   <!-- ************************************************************************* -->

   <menu width="150">
    <top>
      <section>
         <name>Objects</name>
         <item>static_set</item> 
         <item>array</item> 
         <item>array2d</item> 
         <item>binary_search_tree</item> 
         <item>hash_map</item> 
         <item>hash_set</item> 
         <item>hash_table</item> 
         <item>directed_graph</item> 
         <item>graph</item> 
         <item>map</item> 
         <item>queue</item> 
         <item>reference_counter</item> 
         <item>type_safe_union</item> 
         <item>unordered_pair</item> 
         <item>sequence</item> 
         <item>set</item> 
         <item>stack</item> 
         <item>std_vector_c</item> 
         <item>static_map</item> 
         <item>sliding_buffer</item>
         <item>circular_buffer</item>
         <item>tuple</item>
         <item>reference_wrapper</item>
         <item>optional</item>
      </section>

      <section>
         <name>Type Erasure</name>
         <item>any</item> 
         <item>any_trainer</item> 
         <item>any_function</item> 
         <item>any_decision_function</item> 
         <item>storage_heap</item> 
         <item>storage_stack</item> 
         <item>storage_sbo</item> 
         <item>storage_shared</item> 
         <item>storage_view</item> 
      </section>

      <section>
         <name>Interfaces</name>
         <item>map_pair</item> 
         <item>enumerable</item> 
         <item>
            <name>remover</name>
            <sub>
               <item>
                  <name>remover</name>
                  <link>dlib/interfaces/remover.h.html#remover</link>
               </item>
               <item>
                  <name>asc_remover</name>
                  <link>dlib/interfaces/remover.h.html#asc_remover</link>
               </item>
               <item>
                  <name>pair_remover</name>
                  <link>dlib/interfaces/remover.h.html#pair_remover</link>
               </item>
               <item>
                  <name>asc_pair_remover</name>
                  <link>dlib/interfaces/remover.h.html#asc_pair_remover</link>
               </item>
            </sub>   
         </item>     
      </section>     
    </top>
   </menu>

   <!-- ************************************************************************* -->
   <!-- ************************************************************************* -->
   <!-- ************************************************************************* -->

   <components>
   
      <component>
         <name>array</name>
         <file>dlib/array.h</file>
         <spec_file>dlib/array/array_kernel_abstract.h</spec_file>
         <description>
             This object represents a 1-Dimensional array of objects.
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>sliding_buffer</name>
         <file>dlib/sliding_buffer.h</file>
         <spec_file>dlib/sliding_buffer/sliding_buffer_kernel_abstract.h</spec_file>
         <description>
            This object represents an array with the ability to rotate its contents
            left or right.  Note that the size of this object is always a power of two.
            If you need arbitrary sized objects then use a <a href="#circular_buffer">circular_buffer</a>.
         </description>
         
         <implementations>
            <implementation>
               <name>sliding_buffer_kernel_1</name>
               <file>dlib/sliding_buffer/sliding_buffer_kernel_1.h</file>
               <description> 
                  This object is implemented using a C style array in the obvious way.  See the code for details. 
               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for sliding_buffer_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                     
         </implementations>
                        
      </component>
            
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>circular_buffer</name>
         <file>dlib/sliding_buffer.h</file>
         <spec_file>dlib/sliding_buffer/circular_buffer_abstract.h</spec_file>
         <description>
            This object represents a simple sliding buffer which can contain
            and arbitrary number of elements.
         </description>
      </component>
            
   <!-- ************************************************************************* -->
      
      
      <component>
         <name>array2d</name>
         <file>dlib/array2d.h</file>
         <spec_file>dlib/array2d/array2d_kernel_abstract.h</spec_file>
         <description>
                This object represents a 2-Dimensional array of objects.
         </description>

         <examples>
            <example>image_ex.cpp.html</example>
         </examples>
         
      </component>
            
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>binary_search_tree</name>
         <file>dlib/binary_search_tree.h</file>
         <spec_file>dlib/binary_search_tree/binary_search_tree_kernel_abstract.h</spec_file>
         <description>
            This object represents a data dictionary that is built on top of some kind of binary search tree.  
         </description>
         
         <implementations>
            <implementation>
               <name>binary_search_tree_kernel_1</name>
               <file>dlib/binary_search_tree/binary_search_tree_kernel_1.h</file>
               <description> 
        This implementation is done using an AVL binary search tree.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.
     </description>  
  
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for binary_search_tree_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
            <implementation>
               <name>binary_search_tree_kernel_2</name>
               <file>dlib/binary_search_tree/binary_search_tree_kernel_2.h</file>
               <description> 
                  This implementation is done using a red-black binary search tree.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               </description> 
               <typedefs>
                  <typedef>
                     <name>kernel_2a</name>
                     <description>is a typedef for binary_search_tree_kernel_2</description>
                  </typedef>
               </typedefs>                
               
            </implementation>          
         </implementations>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>hash_map</name>
         <file>dlib/hash_map.h</file>
         <spec_file>dlib/hash_map/hash_map_kernel_abstract.h</spec_file>
         <description>
            This object represents a hashed mapping of items of type domain onto items of type range. 
         </description>
         
         <implementations>
            <implementation>
               <name>hash_map_kernel_1</name>
               <file>dlib/hash_map/hash_map_kernel_1.h</file>
               <description> 
                  This implementation is done using a <a href="#hash_table">hash_table</a> object. It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               </description> 
   
 
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for hash_map_kernel_1 that uses hash_table_kernel_1a</description>
                  </typedef>
                  <typedef>
                     <name>kernel_1b</name>
                     <description>is a typedef for hash_map_kernel_1 that uses hash_table_kernel_2a</description>
                  </typedef>
                  <typedef>
                     <name>kernel_1c</name>
                     <description>is a typedef for hash_map_kernel_1 that uses hash_table_kernel_2b</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         
                        
         </implementations>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>hash_set</name>
         <file>dlib/hash_set.h</file>
         <spec_file>dlib/hash_set/hash_set_kernel_abstract.h</spec_file>
         <description>
            This object represents a hashed unordered and unaddressed collection of unique items. 
         </description>
         
         <implementations>
            <implementation>
               <name>hash_set_kernel_1</name>
               <file>dlib/hash_set/hash_set_kernel_1.h</file>
               <description> 
                  This implementation is done using a <a href="#hash_table">hash_table</a> object. It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               </description> 
   
 
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for hash_set_kernel_1 that uses hash_table_kernel_1a</description>
                  </typedef>
                  <typedef>
                     <name>kernel_1b</name>
                     <description>is a typedef for hash_set_kernel_1 that uses hash_table_kernel_2a</description>
                  </typedef>
                  <typedef>
                     <name>kernel_1c</name>
                     <description>is a typedef for hash_set_kernel_1 that uses hash_table_kernel_2b</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         
                        
         </implementations>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>hash_table</name>
         <file>dlib/hash_table.h</file>
         <spec_file>dlib/hash_table/hash_table_kernel_abstract.h</spec_file>
         <description>
            This object represents a data dictionary that is built on top of some kind of 
            hash table. 
         </description>
         
         <implementations>
            <implementation>
               <name>hash_table_kernel_1</name>
               <file>dlib/hash_table/hash_table_kernel_1.h</file>
               <description> 
                  This implementation is done using singly linked lists as hashing buckets.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               </description> 
   
  
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for hash_table_kernel_1. </description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         
            <implementation>
               <name>hash_table_kernel_2</name>
               <file>dlib/hash_table/hash_table_kernel_2.h</file>
               <description> 
                  This implementation is done using <a href="#binary_search_tree">
                  binary_search_tree</a> objects as hashing buckets.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 

               </description> 
    
  
               <typedefs>
                  <typedef>
                     <name>kernel_2a</name>
                     <description>is a typedef for hash_table_kernel_2 that uses binary_search_tree_kernel_1</description>
                  </typedef>
                  <typedef>
                     <name>kernel_2b</name>
                     <description>is a typedef for hash_table_kernel_2 that uses binary_search_tree_kernel_2</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         
                        
         </implementations>
         
               
      </component>
      
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>map</name>
         <file>dlib/map.h</file>
         <spec_file>dlib/map/map_kernel_abstract.h</spec_file>
         <description>
            This object represents a mapping of items of type domain onto items of type range.
         </description>
         
         <implementations>
            <implementation>
               <name>map_kernel_1</name>
               <file>dlib/map/map_kernel_1.h</file>
               <description> 
                  This is implemented using the <a href="#binary_search_tree">binary_search_tree</a> component. It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               </description> 
   
      
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for map_kernel_1 that uses binary_search_tree_kernel_1</description>
                  </typedef>
                  <typedef>
                     <name>kernel_1b</name>
                     <description>is a typedef for map_kernel_1 that uses binary_search_tree_kernel_2</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         
         
                        
         </implementations>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>enumerable</name>
         <file>dlib/interfaces/enumerable.h</file>
         <spec_file>dlib/interfaces/enumerable.h</spec_file>
         <description>
            This object is an abstract class which represents an interface for iterating over 
            all the elements of a container. 
         </description>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>map_pair</name>
         <file>dlib/interfaces/map_pair.h</file>
         <spec_file>dlib/interfaces/map_pair.h</spec_file>
         <description>
            This object is an abstract class which represents an interface for accessing a 
            pair from a container such as the map, hash_table, etc. 
         </description>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>remover</name>
         <file>dlib/interfaces/remover.h</file>
         <spec_file>dlib/interfaces/remover.h</spec_file>
         <description>
            This is a set of interfaces which gives the ability to remove all the items in a 
            container without actually knowing what kind of container contains them. 
         </description>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->

      <component>
         <name>type_safe_union</name>
         <file>dlib/type_safe_union.h</file>
         <spec_file link="true">dlib/type_safe_union/type_safe_union_kernel_abstract.h</spec_file>
         <description>
                This object is a type safe analogue of the classic C union object. 
                The type_safe_union, unlike a union, can contain non-POD types such 
                as std::string.    
                <p>It is also implemented without performing any
                   heap memory allocations and instead it stores everything on the stack.</p>
         </description>
         
         <examples>
            <example>pipe_ex_2.cpp.html</example>
            <example>bridge_ex.cpp.html</example>
         </examples>
         
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>unordered_pair</name>
         <file>dlib/unordered_pair.h</file>
         <spec_file link="true">dlib/unordered_pair.h</spec_file>
         <description>
                This object is very similar to the std::pair struct except unordered_pair 
                is only capable of representing an unordered set of two items rather than 
                an ordered list of two items like std::pair.  
         </description>
         
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>storage_heap</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/storage.h</spec_file>
         <description>
                This object is basically a type-safe version of a void*.  In particular,
                it is a container which can contain only one object but the object may
                be of any type.  Importantly, this container stores the object <b>on the 
                heap</b>.

               <p>
                  This class is meant to be a lower level tool used to implement other 
                  higher level containers or APIs that depend on type erasure.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>storage_stack</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/storage.h</spec_file>
         <description>
                This object is basically a type-safe version of a void*.  In particular,
                it is a container which can contain only one object but the object may
                be of any type.  Importantly, this container stores the object <b>on the 
                stack</b>.

               <p>
                  This class is meant to be a lower level tool used to implement other 
                  higher level containers or APIs that depend on type erasure.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>storage_sbo</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/storage.h</spec_file>
         <description>
                This object is basically a type-safe version of a void*.  In particular,
                it is a container which can contain only one object but the object may
                be of any type.  This container uses the <b>small buffer optimization</b>
                to store small objects on the stack, but larger objects on the heap.

               <p>
                  This class is meant to be a lower level tool used to implement other 
                  higher level containers or APIs that depend on type erasure.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>storage_shared</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/storage.h</spec_file>
         <description>
                This object is basically a type-safe version of a void*.  In particular,
                it is a container which can contain only one object but the object may
                be of any type.  This container stores the object it contains in a <tt>std::shared_ptr</tt>,
                and therefore has reference rather than value semantics, as well as storage on the heap.

               <p>
                  This class is meant to be a lower level tool used to implement other 
                  higher level containers or APIs that depend on type erasure.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>storage_view</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/storage.h</spec_file>
         <description>
                This object is basically a type-safe version of a void*.  In particular,
                it is a container which can contain only one object but the object may
                be of any type.  This container doesn't actually store the object it contains,
                rather, it is a non-owning view of that object.  It therefore has reference
                semantics just as a void* would.

               <p>
                  This class is meant to be a lower level tool used to implement other 
                  higher level containers or APIs that depend on type erasure.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>any</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/any_abstract.h</spec_file>
         <description>
                This object is basically a type-safe version of a void*.  In particular,
                it is a container which can contain only one object but the object may
                be of any type.  

               <p>
                It is somewhat like the <a href="#type_safe_union">type_safe_union</a> except you don't have to declare 
                the set of possible content types beforehand.  So in some sense this is 
                like a less type-strict version of the type_safe_union.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>any_decision_function</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/any_decision_function_abstract.h</spec_file>
         <description>
               This object is a version of dlib::<a href="#any">any</a> that is restricted to containing 
                elements which are some kind of function object with an operator() with 
                the following signature: 
                <tt>result_type operator()(const sample_type&amp;) const</tt>

               <p>
                  It is intended to be used to contain dlib::<a href="ml.html#decision_function">decision_function</a> 
                  objects and other types which represent learned decision functions.  It allows you
                to write code which contains and processes these decision functions
                without needing to know the specific types of decision functions used.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>any_function</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/any_function_abstract.h</spec_file>
         <description>
                This object is a version of dlib::<a href="#any">any</a> that is restricted to containing 
                elements which are some kind of function or function object.    
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>any_trainer</name>
         <file>dlib/any.h</file>
         <spec_file link="true">dlib/any/any_trainer_abstract.h</spec_file>
         <description>
                This object is a version of dlib::<a href="#any">any</a> that is restricted to containing 
                elements which are some kind of object with a .train() method compatible 
                with the following signature: 
<pre> decision_function train(
      const std::vector&lt;sample_type&gt;&amp; samples,
      const std::vector&lt;scalar_type&gt;&amp; labels
   ) const
</pre>
                  Where <tt>decision_function</tt> is a type capable of being stored in an
                    <a href="#any_decision_function">any_decision_function</a> object.

               <p>
                  any_trainer is intended to be used to contain objects such as the <a href="ml.html#svm_nu_trainer">svm_nu_trainer</a>
                and other similar types which represent supervised machine learning algorithms.   
                It allows you to write code which contains and processes these trainer objects 
                without needing to know the specific types of trainer objects used.
               </p>
         </description>
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>tuple</name>
         <file>dlib/tuple.h</file>
         <spec_file>dlib/tuple/tuple_abstract.h</spec_file>
         <description>
                This is an implementation of a very simple templated container object.
                It contains between 0 and 31 objects where each object is listed
                explicitly in the tuple's template arguments.   

            <p>
               Note that there is only one implementation of this object so there aren't any
               different kernels to choose from when you create instances of the tuple object.  
               So for example, you
               could declare a tuple of 3 ints using the following statement: 
               <tt>dlib::tuple&lt;int,int,int&gt; t;</tt>  
            </p>
         </description>
               
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>reference_wrapper</name>
         <file>dlib/ref.h</file>
         <spec_file>dlib/ref.h</spec_file>
         <description>
                This is a simple object that just holds a reference to another object. 
                It is useful because it can serve as a kind of "copyable reference".  
         </description>
         <examples>
            <example>thread_function_ex.cpp.html</example>
         </examples>
               
      </component>
      
   <!-- ************************************************************************* -->

      <component>
         <name>optional</name>
         <file>dlib/optional.h</file>
         <spec_file>dlib/optional.h</spec_file>
         <description>
            This is a standard's compliant backport of <a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a> 
            that works with C++14.  It includes C++23 monadic interfaces
         </description>
      </component>
      
   <!-- ************************************************************************* -->

      <component checked="true">
         <name>graph</name>
         <file>dlib/graph.h</file>
         <spec_file>dlib/graph/graph_kernel_abstract.h</spec_file>
         <description>
                This object represents a graph which is a set of nodes with undirected
                edges connecting various nodes.  
         </description>
         
         <implementations>
            <implementation>
               <name>graph_kernel_1</name>
               <file>dlib/graph/graph_kernel_1.h</file>
               <description> 
                  This is implemented using std::vector to contain all the nodes and edges.   
               </description> 

               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for graph_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         </implementations>
         
      </component>
      
      
   <!-- ************************************************************************* -->
      <component checked="true">
         <name>directed_graph</name>
         <file>dlib/directed_graph.h</file>
         <spec_file>dlib/directed_graph/directed_graph_kernel_abstract.h</spec_file>
         <description>
                This object represents a directed graph which is a set of nodes with directed
                edges connecting various nodes.  
         </description>
         
         <implementations>
            <implementation>
               <name>directed_graph_kernel_1</name>
               <file>dlib/directed_graph/directed_graph_kernel_1.h</file>
               <description> 
                  This is implemented using std::vector to contain all the nodes and edges.   
               </description> 

               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for directed_graph_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
         </implementations>
         
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>queue</name>
         <file>dlib/queue.h</file>
         <spec_file>dlib/queue/queue_kernel_abstract.h</spec_file>
         <description>
            This object represents a first in first out queue. 
         </description>
         
         <examples>
            <example>queue_ex.cpp.html</example>
         </examples>

         <implementations>
            <implementation>
               <name>queue_kernel_1</name>
               <file>dlib/queue/queue_kernel_1.h</file>
               <description> 
                  This is implemented in the obvious way using a singly linked list.  It does not use the 
        <a href="other.html#memory_manager">memory_manager</a> at all. 
               </description> 

               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for queue_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
            <implementation>
               <name>queue_kernel_2</name>
               <file>dlib/queue/queue_kernel_2.h</file>
               <description> 
               This is implemented using a singly linked list and each node in the list
               contains block_size (a template parameter) elements.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_2a</name>
                     <description>is a typedef for queue_kernel_2 with a block_size of 20</description>
                  </typedef>
                  <typedef>
                     <name>kernel_2b</name>
                     <description>is a typedef for queue_kernel_2 with a block_size of 100</description>
                  </typedef>
               </typedefs>                
               
            </implementation>          
         </implementations>
         
         <extensions>
            <extension>
               <name>queue_sort</name>
               <spec_file>dlib/queue/queue_sort_abstract.h</spec_file>
               <description> 
                  This extension gives a queue the ability to sort its contents.
               </description> 

               <implementations>
                  <implementation>
                     <name>queue_sort_1</name>
                     <file>dlib/queue/queue_sort_1.h</file>
                     <description> 
                        This is a version of the QuickSort algorithm.
                     </description> 
    
                     <typedefs>
                        <typedef>
                           <name>sort_1a</name>
                           <description>is a typedef for queue_kernel_1a extended by queue_sort_1</description>
                        </typedef>
                        <typedef>
                           <name>sort_1b</name>
                           <description>is a typedef for queue_kernel_2a extended by queue_sort_1</description>
                        </typedef>
                        <typedef>
                           <name>sort_1c</name>
                           <description>is a typedef for queue_kernel_2b extended by queue_sort_1</description>
                        </typedef>
                     </typedefs>                
                     
                  </implementation> 
                           
               </implementations>
   
               
            </extension>
         </extensions>
               
      </component>
      
      
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>reference_counter</name>
         <file>dlib/reference_counter.h</file>
         <spec_file>dlib/reference_counter/reference_counter_kernel_abstract.h</spec_file>
         <description>
            This object represents a container for an object and provides reference counting
            capabilities for the object it contains. 
         </description>
         
         <implementations>
            <implementation>
               <name>reference_counter_kernel_1</name>
               <file>dlib/reference_counter/reference_counter_kernel_1.h</file>
               <description> 
                  This implementation is done using pointers in the obvious way.
               </description> 

               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for reference_counter_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                        
         </implementations>
         
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>sequence</name>
         <file>dlib/sequence.h</file>
         <spec_file>dlib/sequence/sequence_kernel_abstract.h</spec_file>
         <description>
            This object represents an ordered sequence of items, each item is 
            associated with an integer value. The items are numbered from 0 to the number of items in the 
            sequence minus 1. 
         </description>
         
         <implementations>
            <implementation>
               <name>sequence_kernel_1</name>
               <file>dlib/sequence/sequence_kernel_1.h</file>
               <description> 
                  This is implemented as an AVL binary search tree.  
                  Accessing(or adding or removing) an element always takes O(log n) time.  
 It uses the <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 
               </description> 

               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for sequence_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
            <implementation>
               <name>sequence_kernel_2</name>
               <file>dlib/sequence/sequence_kernel_2.h</file>
               <description> 
                  This implementation is done using a doubly linked list in the shape of a ring.  
                  It will remember the last element accessed(or added or removed) and give O(1) 
                  access time to the elements just left and right of it.  Aside from that, 
                  accessing(or adding or removing) a random element will take O(n) and in the worst 
                  case it will take time proportional to the size of the sequence/2.  
      <p>
                     It does not use the 
                     <a href="other.html#memory_manager">memory_manager</a> at all. 
      </p>

               </description> 

               <typedefs>
                  <typedef>
                     <name>kernel_2a</name>
                     <description>is a typedef for sequence_kernel_2</description>
                  </typedef>
               </typedefs>                
               
            </implementation>          
         </implementations>
         
         <extensions>
      
            <extension>
               <name>sequence_sort</name>
               <spec_file>dlib/sequence/sequence_sort_abstract.h</spec_file>
               <description> 
                  This extension gives a sequence the ability to sort its contents.
               </description> 

               <implementations>
                  <implementation>
                     <name>sequence_sort_1</name>
                     <file>dlib/sequence/sequence_sort_1.h</file>
                     <description> 
                        This is a version of the QuickSort algorithm and it sorts sequences of less 
                        than 30 elements with a selection sort.  This implementation is fastest when 
                        used with sequence_kernel_2 and fairly slow when used with sequence_kernel_1                       
                     </description> 

                     <typedefs>
                        <typedef>
                           <name>sort_1a</name>
                           <description>is a typedef for sequence_kernel_2a extended by sequence_sort_1</description>
                        </typedef>
                     </typedefs>                
                     
                  </implementation> 
                  <implementation>
                     <name>sequence_sort_2</name>
                     <file>dlib/sequence/sequence_sort_2.h</file>
                     <description> 
                        This is a version of the QuickSort algorithm.  This implementation of sort is 
                        the best to use with sequence_kernel_1 objects but gives extremely poor performance 
                        with sequence_kernel_2 objects.
                     </description> 

                     <typedefs>
                        <typedef>
                           <name>sort_2a</name>
                           <description>is a typedef for sequence_kernel_1a extended by sequence_sort_2</description>
                        </typedef>
                     </typedefs>                
                     
                  </implementation>          
               </implementations>
   
               
            </extension>
            <extension>
               <name>sequence_compare</name>
               <spec_file>dlib/sequence/sequence_compare_abstract.h</spec_file>
               <description> 
                  This extension gives sequences the ability to compare themselves using 
                  operator&lt; and operator==.  Thus they can be used in the other container classes 
                  that require this ability. (maps, sets, etc.)
               </description> 

               <implementations>
                  <implementation>
                     <name>sequence_compare_1</name>
                     <file>dlib/sequence/sequence_compare_1.h</file>
                     <description> 
                        The implementation is obvious.  Click on the sequence_compare_1 link if you want to see.                       
                     </description> 

                     <typedefs>
                        <typedef>
                           <name>compare_1a</name>
                           <description>is a typedef for sequence_kernel_1a extended by sequence_compare_1</description>
                        </typedef>
                        <typedef>
                           <name>compare_1b</name>
                           <description>is a typedef for sequence_kernel_2a extended by sequence_compare_1</description>
                        </typedef>
                     </typedefs>                
                     
                  </implementation> 
                           
               </implementations>
   
               
            </extension>
         </extensions>
               
      </component>
      
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>set</name>
         <file>dlib/set.h</file>
         <spec_file>dlib/set/set_kernel_abstract.h</spec_file>
         <description>
            This object represents an unordered and unaddressed collection of unique items. 
         </description>
         
         <implementations>
            <implementation>
               <name>set_kernel_1</name>
               <file>dlib/set/set_kernel_1.h</file>
               <description> 
                  This is implemented using the <a href="#binary_search_tree">binary_search_tree</a> component.   It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations.

               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for set_kernel_1 that uses binary_search_tree_kernel_1</description>
                  </typedef>
                  <typedef>
                     <name>kernel_1b</name>
                     <description>is a typedef for set_kernel_1 that uses binary_search_tree_kernel_2</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                     
         </implementations>
         
         <extensions>
      
            <extension>
               <name>set_compare</name>
               <spec_file>dlib/set/set_compare_abstract.h</spec_file>
               <description> 
                  This extension gives sets the ability to compare themselves using operator&lt; and 
                  operator==.  Thus they can be used in the other container classes that require 
                  this ability. (maps, sets, etc.)
               </description> 

               <implementations>
                  <implementation>
                     <name>set_compare_1</name>
                     <file>dlib/set/set_compare_1.h</file>
                     <description> 
                        The implementation is obvious.  Click on the set_compare_1 link if you want to see.                      
                     </description> 

                     <typedefs>
                        <typedef>
                           <name>compare_1a</name>
                           <description>is a typedef for set_kernel_1a extended by set_compare_1</description>
                        </typedef>
                        <typedef>
                           <name>compare_1b</name>
                           <description>is a typedef for set_kernel_1b extended by set_compare_1</description>
                        </typedef>
                     </typedefs>                
                     
                  </implementation> 
                           
               </implementations>
   
               
            </extension>
         </extensions>
               
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>stack</name>
         <file>dlib/stack.h</file>
         <spec_file>dlib/stack/stack_kernel_abstract.h</spec_file>
         <description>
            This object represents a last in first out stack. 
         </description>
         
         <implementations>
            <implementation>
               <name>stack_kernel_1</name>
               <file>dlib/stack/stack_kernel_1.h</file>
               <description> 
                  This implementation is done in the obvious way using a singly linked list.  It uses the 
        <a href="other.html#memory_manager">memory_manager</a> for all memory allocations. 

               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for stack_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                     
         </implementations>
                        
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>static_map</name>
         <file>dlib/static_map.h</file>
         <spec_file>dlib/static_map/static_map_kernel_abstract.h</spec_file>
         <description>
            This object represents a mapping of items of type domain onto items of type range. 
            The difference between this object and the normal <a href="#map">map</a> object is that it does not support adding
            or removing individual objects from itself.  This allows implementations to focus on using less memory and 
            achieving faster searching. 
         </description>
         
         <implementations>
            <implementation>
               <name>static_map_kernel_1</name>
               <file>dlib/static_map/static_map_kernel_1.h</file>
               <description> 
                  This implementation is just a sorted array which can be searched using a binary search.  
               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for static_map_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                     
         </implementations>
                        
      </component>
      
      
   <!-- ************************************************************************* -->
      
      <component checked="true">
         <name>static_set</name>
         <file>dlib/static_set.h</file>
         <spec_file>dlib/static_set/static_set_kernel_abstract.h</spec_file>
         <description>
            This object represents an unordered and unaddressed collection of items. 
            The difference between this object and the normal <a href="#set">set</a> object is that it does not support adding
            or removing individual objects from itself.  This allows implementations to focus on using less memory and 
            achieving faster searching. 
         </description>
         
         <implementations>
            <implementation>
               <name>static_set_kernel_1</name>
               <file>dlib/static_set/static_set_kernel_1.h</file>
               <description> 
                  This implementation is just a sorted array which can be searched using a binary search.  
               </description> 
    
               <typedefs>
                  <typedef>
                     <name>kernel_1a</name>
                     <description>is a typedef for static_set_kernel_1</description>
                  </typedef>
               </typedefs>                
               
            </implementation> 
                     
         </implementations>
         
         <extensions>
      
            <extension>
               <name>static_set_compare</name>
               <spec_file>dlib/static_set/static_set_compare_abstract.h</spec_file>
               <description> 
                  This extension gives static_sets the ability to compare themselves using operator&lt; and 
                  operator==.  Thus they can be used in the other container classes that require 
                  this ability. (maps, static_sets, etc.)
               </description> 

               <implementations>
                  <implementation>
                     <name>static_set_compare_1</name>
                     <file>dlib/static_set/static_set_compare_1.h</file>
                     <description> 
                        The implementation is obvious.  Click on the static_set_compare_1 link if you want to see.                        
                     </description> 

                     <typedefs>
                        <typedef>
                           <name>compare_1a</name>
                           <description>is a typedef for static_set_kernel_1a extended by static_set_compare_1</description>
                        </typedef>
                     </typedefs>                
                     
                  </implementation> 
                           
               </implementations>
   
               
            </extension>
         </extensions>
               
      </component>
      
   <!-- ************************************************************************* -->
      
      <component>
         <name>std_vector_c</name>
         <file>dlib/stl_checked.h</file>
         <spec_file link="true">dlib/stl_checked/std_vector_c_abstract.h</spec_file>
         <description>
            This object is a simple wrapper around the std::vector object.  It 
            provides an identical interface but also checks the preconditions of
            each member function.  That is, if you violate a requires
            clause the dlib::fatal_error exception is thrown. 
         </description>
      </component>
      
   <!-- ************************************************************************* -->
      
   </components>

   <!-- ************************************************************************* -->


</doc>
