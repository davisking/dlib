# This is a CMake file that sets up the add_python_module() macro.  This macro
# lets you easily make python modules that use dlib.  
#
# The macro takes the module name as its first argument and then a list of
# source files to compile into the module.  See ../tools/python/CMakeLists.txt
# for an example.
#
# It also sets up a macro called install_${module_name}_to() where
# ${module_name} is whatever you named your module.  This install_*_to() macro
# takes a folder name and creates an install target that will copy the compiled
# python module to that folder when you run "make install".  Note that the path
# given to install_*_to() is relative to your CMakeLists.txt file.
#


option(PYTHON3 "Build a Python3 compatible library rather than Python2." OFF)

# Avoid cmake warnings about changes in behavior of some Mac OS X path 
# variable we don't care about.
if (POLICY CMP0042)
    cmake_policy(SET CMP0042 NEW)
endif()


# Sometimes a computer will have multiple python verions installed.  So in this
# block of code we find the one in the user's path and add its home folder into
# cmake's search path.  That way it will use that version of python first. 
if (PYTHON3)
    find_program(PYTHON_EXECUTABLE python3)
endif()
if (NOT PYTHON_EXECUTABLE)
    find_program(PYTHON_EXECUTABLE python)
endif()
# Resolve symbolic links, hopefully this will give us a path in the proper
# python home directory.
get_filename_component(PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE} REALPATH)
# Pick out the parent directories
get_filename_component(PYTHON_PATH ${PYTHON_EXECUTABLE} PATH)
get_filename_component(PYTHON_PATH ${PYTHON_PATH} PATH)
list(APPEND CMAKE_PREFIX_PATH "${PYTHON_PATH}")


# To avoid dll hell, always link everything statically when compiling in
# visual studio.  This way, the resulting library won't depend on a bunch
# of other dll files and can be safely copied to someone elese's computer
# and expected to run.
if (MSVC)
    include(${CMAKE_CURRENT_LIST_DIR}/tell_visual_studio_to_use_static_runtime.cmake)
endif()

if (PYTHON3)
    set(Python_ADDITIONAL_VERSIONS 3.5 3.6)
    FIND_PACKAGE(PythonLibs 3.4)
    set(PYBIND11_PYTHON_VERSION 3.4)
else()
    FIND_PACKAGE(PythonLibs 2.6)
    set(PYBIND11_PYTHON_VERSION 2.6)
endif()

if (CMAKE_COMPILER_IS_GNUCXX)
    # Just setting CMAKE_POSITION_INDEPENDENT_CODE should be enough to set
    # -fPIC for GCC but sometimes it still doesn't get set, so make sure it
    # does.
    add_definitions("-fPIC")
    set(CMAKE_POSITION_INDEPENDENT_CODE True)
else()
    set(CMAKE_POSITION_INDEPENDENT_CODE True)
endif()

# include dlib so we can link against it
add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/.. dlib_build)
if (USING_OLD_VISUAL_STUDIO_COMPILER)
   message(FATAL_ERROR "You have to use a version of Visual Studio that supports C++11.  As of December 2017, the only versions that have good enough C++11 support to compile the dlib Pyhton API is a fully updated Visual Studio 2015 or a fully updated Visual Studio 2017.  Older versions of either of these compilers have bad C++11 support and will fail to compile the Python extension. ***SO UPDATE YOUR VISUAL STUDIO TO MAKE THIS ERROR GO AWAY***")
endif()

if (WIN32)
    message(STATUS "USING PYTHON_LIBS: ${PYTHON_LIBRARIES}")
endif()

# We put the extra _ on the end of the name just so it's possible to
# have a module name of dlib and not get a conflict with the target named
# dlib in ../dlib/cmake.  We use the target OUPUT_NAME property to ensure the
# output name is set to what the user asked for (i.e. no _).
macro(add_python_module module_name module_sources )
   ADD_LIBRARY(${module_name}_ SHARED ${module_sources} ${ARGN} )
   TARGET_LINK_LIBRARIES(${module_name}_ dlib::dlib)

    target_include_directories(${module_name}_ SYSTEM PUBLIC "${Boost_INCLUDE_DIRS}")
    if (PYTHON_INCLUDE_PATH)
        target_include_directories(${module_name}_ SYSTEM PUBLIC "${PYTHON_INCLUDE_PATH}" )
    else()
        target_include_directories(${module_name}_ SYSTEM PUBLIC "${PYTHON_INCLUDE_DIRS}" )
    endif()


   if(WIN32 AND NOT CYGWIN)
      TARGET_LINK_LIBRARIES(${module_name}_ ${PYTHON_LIBRARIES})
      SET_TARGET_PROPERTIES( ${module_name}_
         PROPERTIES
         PREFIX ""
         SUFFIX ".pyd"
         OUTPUT_NAME ${module_name}
         )
   elseif(CYGWIN)
      SET_TARGET_PROPERTIES( ${module_name}_
         PROPERTIES
         PREFIX ""
         SUFFIX ".dll"
         OUTPUT_NAME ${module_name}
         )
    elseif(APPLE)
      SET_TARGET_PROPERTIES( ${module_name}_
         PROPERTIES
         LINK_FLAGS "-undefined dynamic_lookup"
         PREFIX ""
         SUFFIX ".so"
         OUTPUT_NAME ${module_name}
         )
   else()
      SET_TARGET_PROPERTIES( ${module_name}_
         PROPERTIES
         LINK_FLAGS "-shared"
         PREFIX ""
         SUFFIX ".so"
         OUTPUT_NAME ${module_name}
         )
   endif()

   macro(install_${module_name}_to path)
       # Determine the path to our CMakeLists.txt file.
       string(REGEX REPLACE "CMakeLists.txt$" "" base_path ${CMAKE_CURRENT_LIST_FILE})
       INSTALL(TARGETS ${module_name}_ 
            RUNTIME DESTINATION  "${base_path}/${path}"
            LIBRARY DESTINATION  "${base_path}/${path}"
           )
   endmacro()

endmacro()



